#!/usr/bin/python3
#pythondialog needed
#TODO:absolutely test folder changes!
#TODO: add test\check subprogram

import argparse
import xml.etree.ElementTree as ET
from ftplib import FTP
from os.path import isfile
from os.path import expanduser
from os.path import isdir
from os.path import exists
from os.path import basename
from os import makedirs
DEBUG=1
home=expanduser("~")
configuration_file_path=home+'/.config/ftp-backup.cfg'
version='ftp-backup v0.1'
def main():
    parser=argparse.ArgumentParser(description='Backup your smartphone wirelessly thru ftp',epilog='Created by Filippo Volpe (filippodalfarra98@gmail.com).')
    parser.add_argument('-v','--version',action='version',version=version)
    parser.add_argument('--gui',action='store_true',help='use the GUI')
    parser.add_argument('--cli',action='store_true',help='use the CLI')
    #subparsers
    subparsers=parser.add_subparsers(title='subparts')
    #parser_init
    parser_init=subparsers.add_parser('init',help='init a configuration')
    parser_init.add_argument('device_name',help='name of new device',metavar='DEV')
    parser_init.add_argument('address',help='address of ftp server',metavar='ADDR')
    parser_init.add_argument('-p','--port',help='set special port of fpt server',metavar='PORT')
    parser_init.add_argument('-u','--user',help='username to access ftp server',metavar='USER')
    parser_init.add_argument('-k','--passwd',help='password to access ftp server',metavar='PASS')
    parser_init.add_argument('-e','--enable',action='store_true',help='enable immediately the device')
    parser_init.set_defaults(func=initf)
    #parser_modconf
    parser_modconf=subparsers.add_parser('modconf',help='modify the configuration')
    parser_modconf.add_argument('device',help='name of device to modify',metavar='DEV')
    parser_modconf.add_argument('-f','--remove-folder',help='remove a folder from configuration',metavar='FOLD')
    parser_modconf.add_argument('-d','--remove-device',action='store_true',help='delete device')
    parser_modconf.set_defaults(func=modconf)
    #parser_addfolder
    parser_addfolder=subparsers.add_parser('addfolder',help='add a folder')
    parser_addfolder.add_argument('device',help='name of device to modify',metavar='DEV')
    parser_addfolder.add_argument('name',help='name of folder',metavar='NAME')
    parser_addfolder.add_argument('source',help='source folder',metavar='SOUR')
    parser_addfolder.add_argument('destination',help='destination folder',metavar='DEST')
    parser_addfolder.add_argument('-f','--filter-type',choices=['e','o'],help='filter type',metavar='FT',default='e')
    parser_addfolder.add_argument('-s','--filter-string',help='filter string',metavar='FS',default='')#the filter string is like 'png,pdf,doc'
    parser_addfolder.add_argument('-i','--include-hidden',action='store_true',help='include hidden files')
    parser_addfolder.add_argument('-e','--enable',action='store_true',help='enable immediately the folder')
    parser_addfolder.add_argument('-R','--recursive',action='store_true',help='recursion through folders')
    parser_addfolder.set_defaults(func=addfolderf)
    #parser_list
    parser_list=subparsers.add_parser('list',help='list all devices')#TODO:adding options?
    parser_list.add_argument('-a','--all',action='store_true',help='all devices with folders')
    parser_list.set_defaults(func=listf)
    #parser_backup
    parser_backup=subparsers.add_parser('backup',help='start a backup')
    parser_backup.add_argument('-a','--all',action='store_true',help='start to backup all active devices')
    parser_backup.add_argument('-d','--device',help='start to backup selected device',metavar='DEV')
    parser_backup.set_defaults(func=backupf)
    ##parsing
    args=parser.parse_args()
    #handle the stuff
    if DEBUG:
        print(args)
    if args.cli:
        cli()
        return
    if args.gui:
        gui()
        return
    if hasattr(args,'func'): #if subprogram is called, call the proper function
        args.func(args)
        return
    #if nothing interrupt it will print the help
    parser.print_help()
def cli():
    cli=argparse.ArgumentParser(add_help=False)
    cli_sub=cli.add_subparsers(description='CLI commands',dest='cli_subprog')
    #
    cli_help=cli_sub.add_parser('help',help='print help')
    #
    cli_connect=cli_sub.add_parser('connect',help='connect to a server')
    cli_connect.add_argument('address',metavar='ADDR')
    cli_connect.add_argument('-p','--port',metavar='PORT')
    #
    cli_login=cli_sub.add_parser('login',help='login to server')
    cli_login.add_argument('user',metavar='USER')
    cli_login.add_argument('passwd',metavar='PASSWD')
    #
    cli_disconnect=cli_sub.add_parser('disconnect',help='disconnect to a server')
    #
    cli_cd=cli_sub.add_parser('cd',help='change working directory')
    cli_cd.add_argument('folder',metavar='FOLD')
    #
    cli_download=cli_sub.add_parser('download',help='download from server')
    cli_download.add_argument('source',metavar='SOUR')
    cli_download.add_argument('destination',metavar='DEST')
    cli_download.add_argument('-a',action='store_true')
    cli_download.add_argument('-R',action='store_true')
    #
    cli_ls=cli_sub.add_parser('ls',help='list directory')
    cli_ls.add_argument('-l',action='store_true')
    #
    cli_exit=cli_sub.add_parser('exit',help='exit from cli')
    #
    while True:
        while True:
            try:
                cli_args=cli.parse_args(input('> ').split(' '))
                break
            except:
                print('\nInvalid stuff')
        if DEBUG:
            print(cli_args)
        cli_subprog=getattr(cli_args,'cli_subprog','')
        if cli_subprog == 'exit':
            break
        elif cli_subprog == 'help':
                cli.print_help()
        elif cli_subprog == 'connect':
            ftps=FTP()
            ftps.connect(cli_args.address,int(getattr(cli_args,'port',0)))
            print('Connected')
        elif cli_subprog == 'login':
            if 'ftps' not in locals():
                print('connect first')
                continue
            ftps.login(cli_args.user,cli_args.passwd)
            print('Logged')
        elif cli_subprog == 'disconnect':
            if 'ftps' in locals():
                del ftps
            print('Disconnected')
        elif cli_subprog == 'cd':
            if 'ftps' not in locals():
                print('connect first')
                continue
            ftps.cwd(cli_args.folder)
            print(ftps.pwd())
            print('Folder changed')
        elif cli_subprog == 'ls':
            if 'ftps' not in locals():
                print('connect first')
                continue
            lines=[]
            ftps.retrlines('LIST',lines.append)
            if not cli_args.l:
                files=[]
                for line in lines:
                    p=0
                    for i in range(0,8): #skip first seven whitespaces
                        while line[p] is not ' ':
                            p+=1
                        p+=1
                    #p = first index of file name
                    word=''
                    while p<len(line):
                        word=word+line[p]
                        p+=1
                    files.append(word)
                lines=files
            print('\n'.join(lines))
        elif cli_subprog == 'download':
            def isFolder(ftps,path):
                current=ftps.pwd()
                try:
                    ftps.cwd(path)
                except:
                    ftps.cwd(current)
                    return False
                ftps.cwd(current)
                return True
            if 'ftps' not in locals():
                print('connect first')
                continue
            #TODO:complete this with rich arguments gived(/folder/*.pmg or . or *) and recursion?
            #source possibilities:
            #/folder download all files inside the folder(-R > also in children)
            #/folder/file.png donwload only the file
            if isFolder(ftps,cli_args.source): #download all the inside
                Folder(cli_args.source,cli_args.source,cli_args.destination,recursive=cli_args.R,include_hidden=cli_args.a).backup(ftps)
            else:#is a file
                dest=cli_args.destination
                if isdir(dest):
                    dest=dest+'/'+basename(cli_args.source)
                ftps.retrbinary('RETR %s' % cli_args.source,open(dest,'wb').write) # for exact file names gived

def gui():
    try:
        from dialog import Dialog#used for gui interaction
    except ImportError:
        print('Please install pythondialog to use the gui :(')
        print('You can run: pip install pythondialog')
        exit(-1)

    pass
def initf(args):
    conf=Configuration(configuration_file_path)
    if DEBUG:
        print('Adding device:',args.device_name)
    conf.addDevice(Device(args.device_name,args.address,args.port,args.user,args.passwd,args.enable))
    conf.write(configuration_file_path)
def addfolderf(args):
    conf=Configuration(configuration_file_path)
    if DEBUG:
        print('Adding folder:',args.device)
    conf.addFolderToDevice(args.device,Folder(args.name,args.source,args.destination,args.filter_type,args.filter_string,args.include_hidden,args.enable,args.recursive))
    conf.write(configuration_file_path)
def listf(args):
    conf=Configuration(configuration_file_path)
    conf.printConfiguration()
def modconf(args):
    conf=Configuration(configuration_file_path)
    if args.remove_device:
        conf.removeDevice(args.device)
    elif args.remove_folder:
        conf.removeFolderFromDevice(args.device,args.remove_folder)
    conf.write(configuration_file_path)
def backupf(args):
    if args.all:
        conf=Configuration(configuration_file_path)
        conf.backupAll()
    elif args.device:
        pass#TODO:device_name=args.device
##Configuration
class Configuration:
    """Configuration containing the devices"""
    default_configuration_file="""<?xml version="1.0"?><configuration></configuration>"""
    #Class parameters:
    #devices[]
    #tree
    #root
    def __init__(self,configuration_file_path):
        self.devices=[]
        if not isfile(configuration_file_path): #create file
            self.createConfigurationFile(configuration_file_path)
        self.tree=ET.parse(configuration_file_path)
        self.root=self.tree.getroot()
        for deviceE in self.root.iter('device'):
            self.devices.append(Device.fromDeviceElement(deviceE))
    def write(self,configuration_file_path):
        #deleting all devices
        for deviceE in self.root.findall('device'):
            self.root.remove(deviceE)
        #re-adding devices
        for device in self.devices:
            self.root.append(device.getDeviceElement())
        #writing new file
        self.tree.write(configuration_file_path)
        if DEBUG:
            ET.dump(self.root)
    def createConfigurationFile(self,configuration_file_path):
        if DEBUG:
            print('Writing default configuration file...')
        configuration_file=open(configuration_file_path,'w')
        configuration_file.write(self.default_configuration_file)
        configuration_file.close()
        if DEBUG:
            print('Configuration file created in ',configuration_file_path,'\nYou can modify it manually at your own risk')
    def addDevice(self,device):
        if not self.checkAvaibleDeviceName(device.name):
            print('Name already used!')
            exit(-1)
        self.devices.append(device)
    def checkAvaibleDeviceName(self,name):
        for device in self.devices:
            if device.name == name:
                if DEBUG:
                    print('Name not avaible')
                return False
        if DEBUG:
            print('Name avaible')
        return True
    def addFolderToDevice(self,device,folder):
        #Search the name
        i=0
        try:
            while(self.devices[i].name != device):
                i+=1
        except IndexError:
            print('Device name not found!')
            exit(-1)
        self.devices[i].addFolder(folder)
    def removeFolderFromDevice(self,device_name,folder_name):
        for device in self.devices:
            if device.name == device_name:
                device.removeFolder(folder_name)
                return
        print('Device not found')
    def removeDevice(self,device_name):
        for device in self.devices:
            if device.name == device_name:
                self.devices.remove(device)
                return
        print('Device not found')
    def printConfiguration(self):
        for device in self.devices:
            device.printDevice()
    def backupAll(self):
        for device in self.devices:
            device.backupAll()
##End Configuration
##Device
class Device:
    """Device class represent a device with all its configuration"""
    def __init__(self,name,address,port=0,user='',passwd='',enable=True,folders=[]):
        self.name=name
        self.address=address
        self.enable=enable
        self.folders=folders
        if port:
            self.port=port
        if user:
            self.user=user
            self.passwd=passwd
        if DEBUG: #Only in debug mode
            print('Device created:')
            self.printDevice()
    @classmethod
    def fromDeviceElement(cls,deviceE):
        port=int(deviceE.get('port')) if deviceE.get('port') else 0
        user=deviceE.get('user') if deviceE.get('user') else ''
        passwd=deviceE.get('passwd') if deviceE.get('passwd') else ''
        enable='true' == deviceE.get('enable')
        folders=[]
        for folderE in deviceE.iter('folder'):
            folders.append(Folder.fromFolderElement(folderE))
        return cls(deviceE.get('name'),deviceE.get('address'),port,user,passwd,enable,folders)

    def getDeviceElement(self):
        deviceE=ET.Element('device')
        deviceE.set('name',self.name)
        deviceE.set('address',self.address)
        deviceE.set('enable',('true' if self.enable else 'false'))
        if hasattr(self,'port'):
            deviceE.set('port',str(self.port))
        if hasattr(self,'user'):
            deviceE.set('user',self.user)
            deviceE.set('passwd',self.passwd)
        for folder in self.folders:
            deviceE.append(folder.getFolderElement())
        return deviceE
    def addFolder(self,folder):
        if not self.checkAvaibleFolderName(folder.name):
            print('Folder name already used!')
            exit(-1)
        self.folders.append(folder)
    def removeFolder(self,folder_name):
        for folder in self.folders:
            if folder.name == folder_name:
                self.folders.remove(folder)
                return
        print('Folder not found')
    def printDevice(self):
        print('\tName:',self.name,'\n\tAddress:',self.address)
        if hasattr(self,'port'):
            print('\tPort:',self.port)
        if hasattr(self,'user'):
            print('\tUser:',self.user,'\n\tPasswd:',self.passwd)
        print('\tEnable:',self.enable)
    def checkAvaibleFolderName(self,name):
        for folder in self.folders:
            if folder.name == name:
                if DEBUG:
                    print('Name not avaible')
                return False
        if DEBUG:
            print('Name avaible')
        return True
    def backupAll(self):
        ftps=FTP()
        print('Connecting to device',self.name,'addr',self.address)
        ftps.connect(self.address,getattr(self,'port',0)) ##connected
        if hasattr(self,'user'):
            print('Logging in to',self.name)
            ftps.login(self.user,self.passwd)
        print('Connected to',self.name)
        for folder in self.folders:#backup each folder
            folder.backup(ftps)
        ftps.close()
##End Device
##Folder
class Folder:
    def __init__(self,name,source,dest,filter_type='e',filter_string='',include_hidden=False,enable=True,recursive=False):
        self.name=name
        self.source=source
        self.dest=dest
        self.include_hidden=include_hidden
        self.filter_type=filter_type
        self.filter_string=filter_string
        self.enable=enable
        self.recursive=recursive
    @classmethod
    def fromFolderElement(cls,folderE):
        return cls(folderE.get('name'),folderE.get('source'),folderE.get('dest'),folderE.get('filter_type'),folderE.get('filter_string'),('true'==folderE.get('include_hidden')),('true'==folderE.get('enable')),('true'==folderE.get('recursive')))

    def getFolderElement(self):
        folderE=ET.Element('folder')
        folderE.set('name',self.name)
        folderE.set('source',self.source)
        folderE.set('dest',self.dest)
        folderE.set('include_hidden','true' if self.include_hidden else 'false')
        folderE.set('filter_type',self.filter_type)
        folderE.set('filter_string',self.filter_string)
        folderE.set('enable','true' if self.enable else 'false')
        folderE.set('recursive','true' if self.recursive else 'false')
        return folderE
    def printFolder(self):
        pass
    def backup(self,ftps):
        def getWordFromFirstIndex(line,index):
            word=''
            while index<len(line):
                word=word+line[index]
                index+=1
            return word
        def excludeAlreadyDownloadedFiles(files,dest):
            files1=[]
            for f in files:
                if not isfile(dest+'/'+f):
                    files1.append(f)
            return files1
        def getExtensionFromFileName(filename): #return the extension without the '.'
                p=len(filename)-1#last character
                extension=[]
                while p != 0 and filename[p] != '.':
                    extension.insert(0,filename[p])
                    p-=1
                if p == 0:#if no extension or hidden file
                    return ''
                return ''.join(extension)
        def getFileNames(retrlines,include_hidden=False,filter_type='e',filter_string=''):
            files=[]
            for line in retrlines:
                if line[0] == '-':##that's a file
                    p=0
                    for i in range(0,8): #skip first eight whitespaces
                        while line[p] != ' ':
                            p+=1
                        p+=1
                    #p = first index of file name
                    if (line[p] != '.') or include_hidden:
                        extension=getExtensionFromFileName(getWordFromFirstIndex(line,p))
                        if ((filter_type == 'e') and ((extension not in filter_string.split(',')) or extension == '')) or ((filter_type == 'o') and (extension in filter_string.split(','))):
                            files.append(getWordFromFirstIndex(line,p))#this file need to be backed up
            return files
        def getFolderNames(retrlines,include_hidden):
            fnames=[]
            for line in retrlines:
                if line[0] == 'd': #thats a directory
                    p=0
                    for i in range(0,8): #skip first eight whitespaces
                        while line[p] != ' ':
                            p+=1
                        p+=1
                    #p = first index of folder name
                    if (line[p] != '.') or include_hidden:
                        fnames.append(getWordFromFirstIndex(line,p))
            return fnames
        if not self.enable:
            return
        current=ftps.pwd()
        ftps.cwd(self.source)
        lines=[]
        ftps.retrlines('LIST',lines.append)
        ftps.cwd(current)
        print('Folder:',self.name)
        files=getFileNames(lines,self.include_hidden,self.filter_type,self.filter_string)
        #if tilde is used
        if self.dest[0] == '~':
            self.dest=self.dest.replace('~',home,1)
        #create destination folder if needed
        if not isdir(self.dest):
            makedirs(self.dest)
        #if a file is present in dest folder, don't download it twice
        files=excludeAlreadyDownloadedFiles(files,self.dest)
        for name in files:
            print('[remote]',self.source+'/'+name,'>>> [local]',self.dest+'/'+name)
            ftps.retrbinary('RETR %s' % self.source+'/'+name,open(self.dest+'/'+name,'wb').write)
        if self.recursive:
            fnames=getFolderNames(lines,self.include_hidden)
            for fname in fnames:
                Folder(fname,self.source+'/'+fname,self.dest+'/'+fname,filter_type=self.filter_type,filter_string=self.filter_string,include_hidden=self.include_hidden,enable=True,recursive=True).backup(ftps)
##End Folder
##Calling the main
if __name__ == '__main__':
    main()
